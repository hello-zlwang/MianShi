# 目录 #

[一、jvm内存](#id1)

​	[1. 程序计数器](#1.程序计数器)

​	[2. java虚拟机栈](#2.java虚拟机栈)

​	[3. 本地方法栈](#3.本地方法栈)

​	[4. 堆](#4.堆)

​	[5. 方法区](#5.方法区)

​	[6. 运行时常量池](#6.运行时常量池)

​	[7. 直接内存](#7.直接内存)

[二、内存分配、对象布局](#id2)





### 一、jvm内存 

---

1. <span id="1.程序计数器">**程序计数器**</span>

   ​	***线程私有***，内存区域极小(几乎可以忽略不计)，可以看做是当前线程执行代码的行号指示器。用于存储指向下一条指令的地址。

   这个区域是唯一一个在java虚拟机栈中没有规定oom[^ OutOfMemory]的区域

   

2. <span id="2.java虚拟机栈">**java虚拟机栈**</span>

   ​	***线程私有***，生命周期与线程相同，是线程运行所需的内存空间。每个栈都由多个栈帧组成，但是每个线程只能有一个活动栈帧。方法在执行的同时，就会创建一个栈帧。栈帧，用来存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法的调用到执行完成，对应着一个栈帧的入栈和出栈。

   ​	局部变量表存储编译时期已知的各种基本类型，和对象引用。局部变量表所需的内存空间在编译器间就完成了分配。64位长度的long和double占用2个solt，其他都是1个solt。

   ​	该区域会抛出stackoverflowerror[^ 栈深度异常]和Outofmemoryerror[^ 内存溢出]。

   

   > a、内存大小设置参数：-xss size(64位下默认1M)
   >
   > b、线程私有、入栈出栈保证了该区域无需进行垃圾回收，也就不会发生GC，

   

3. <span id="3.本地方法栈">**本地方法栈**</span>

   ​	***线程私有***，和java虚拟机作用类似，只是本地方法栈服务的是native方法

   

4. <span id="4.堆">**堆**</span>

   ​	***线程共享***，是java虚拟机中管理的最大的一块内存空间。唯一目的就是存放对象实例。也是垃圾收集的主要区域

    

   > -xms 初始堆内存，-xmx 最大堆内存

   

5. <span id="5.方法区">**方法区**</span>

     ​	***线程共享***，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等。Java虚拟机规范把方法区描述为堆的一个逻辑部分，其实不是堆。而且还有很多人称方法区为永久代，其实并不等价，只是因为GC分代收集扩展至方法区。主要是针对常量池的回收和对类型的卸载。

     > -xx:Permsize 默认20.75M
     >
     > -xx:MaxPermsize 64位最大82M，32位最大64M

     

     ​	**在1.8版本中使用元空间取代了1.7及之前的永久代**。最大的区别就是元空间不在java虚拟机中，而是使用操作内存。修改原因如下：

     ​		a、1.7版本，字符串在永久代中，当字符串较多时，会造成内存不足发生溢出；由于字符串存在永久代，这就造成垃圾收集不能及时将无用字符串进行回收[^ 永久代采用Full Gc]，占用方法区内存。

     ​		b、1.7版本，方法区中还会存储虚拟机加载的类信息，和即时编译器编译后的代码，如果加载的类较多，也会造成oom。

     ​		c、永久代会为GC带来不必要的复杂度，并且回收效率不高

     

      	修改之后的好处：a、不存在元数据空间不足的情况，因为使用的就是系统内存b、FULL GC时，元空间的数据不会被扫描到

     ​	  修改之后的缺点：a、容易造成空间碎片，因为元空间的内存分配是根据类加载器分配的

     

     > -xx:MetaSpacesize  默认21M		
     >
     > -xxMaxMetaSpacesize 默认-1，没有限制
     >
     > ​		元空间的垃圾回收：元空间默认21M，超过21M，就会执行Full GC(类对应的类加载器不在存活)，经过一次Full Gc后，就会调整MetaSpacesize的大小，经过多次调整后，就会调整到最合适的大小。所以，如果前期元空间内存设置较小，会执行多次Full Gc。
     >
     > ​		且回收元空间时的类信息、字节码等只有在加载该类的类加载器被回收后，才会被回收。

      

6. <span id="6.运行时常量池">**运行时常量池**</span>

   ​	是方法区的一部分，class文件中除了有类的版本、字段、方法、接口等信息外，还有常量池。用于存放编译期间生成的各种字面量和符号引用。常量池内容在class文件被加载后就会进入运行时常量池中。

   

7. <span id="7.直接内存">**直接内存**</span>

   ​	并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。

   

---

### <span id="2">二、内存分配、对象布局 </span>

1. **对象创建-内存分配**

   创建对象时，内存的分配有两种方式，一指针碰撞，二空闲列表

   指针碰撞：

   内存空间绝对规整，已使用的空间和未使用的空间区分开来，临界点就是指针。分配空间时，只需要移动指针即可。

   缺点：如果使用空间和未使用空间相互交错，就无法使用

    

   空闲列表：

   维护一个列表，记录那些空间是空闲的，在分配的时候，只需要查找列表即可。

    

   所以根据这两种方法的特点，适用场景不同。

   Serial、parnew采用指针碰撞

   CMS采用空闲列表

    

   空间分配算法大致明确了，但是在并发情况下呢？就如指针碰撞，A线程分配了空间后还未来的及修改指针，B线程就已经获得指针位置了。这样就会出现问题。

   解决方案：

   一、cas操作，这样效率很低啊，分配一个对象就cas操作，

   二、每个线程在java堆中预先分配一小块内存，本地线程分配缓冲区TLAB

   

2. **对象布局**

   对象=对齐填充+对象头+实例数据

   对象头=markword+klass=对象自身运行时数据+类型指针

    

   对象头长度，32位机器，32bit；64位机器，64bit

   对象头的markword存储有hash码、GC分代年龄、锁状态、等信息

    

   对象访问定位：

   句柄访问

   Java堆中分配一快内存作为句柄池，分别指向对象实例数据(堆)和类型(方法区)

   优点：稳定，只需要改变实例数据的指针，引用类型指针不需要修改

   直接访问

   速度快，只需要一次定位

---

---



## 三、垃圾收集

1. 判断对象是否存活



[第一](D:\文档\NB\markdown语法.md)

```
[第一章节笔记](notes/note1.md)
```