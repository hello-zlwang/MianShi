# 目录 #

[一、jvm内存](#id1)

​	[1. 程序计数器](#1.程序计数器)

​	[2. java虚拟机栈](#2.java虚拟机栈)

​	[3. 本地方法栈](#3.本地方法栈)

​	[4. 堆](#4.堆)

​	[5. 方法区](#5.方法区)

​	[6. 运行时常量池](#6.运行时常量池)

​	[7. 直接内存](#7.直接内存)

[二、内存分配、对象布局](#id2)

​	[1. 对象创建、内存分配](#1.内存分配)

​	[2. 对象布局](#2.对象布局)



### 一、jvm内存 

---

1. <span id="1.程序计数器">**程序计数器**</span>

   ​	***线程私有***，内存区域极小(几乎可以忽略不计)，可以看做是当前线程执行代码的行号指示器。用于存储指向下一条指令的地址。

   这个区域是唯一一个在java虚拟机栈中没有规定[^oom]的区域

   

2. <span id="2.java虚拟机栈">**java虚拟机栈**</span>

   ​	***线程私有***，生命周期与线程相同，是线程运行所需的内存空间。每个栈都由多个栈帧组成，但是每个线程只能有一个活动栈帧。方法在执行的同时，就会创建一个栈帧。栈帧，用来存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法的调用到执行完成，对应着一个栈帧的入栈和出栈。

   ​	局部变量表存储编译时期已知的各种基本类型，和对象引用。局部变量表所需的内存空间在编译器间就完成了分配。64位长度的long和double占用2个solt，其他都是1个solt。

   ​	该区域会抛出[^sof]栈深度异常和[^oom]内存溢出。

   

   > a、内存大小设置参数：-xss size(64位下默认1M)
   >
   > b、线程私有、入栈出栈保证了该区域无需进行垃圾回收，也就不会发生GC，

   

3. <span id="3.本地方法栈">**本地方法栈**</span>

   ​	***线程私有***，和java虚拟机作用类似，只是本地方法栈服务的是native方法

   

4. <span id="4.堆">**堆**</span>

   ​	***线程共享***，是java虚拟机中管理的最大的一块内存空间。唯一目的就是存放对象实例。也是垃圾收集的主要区域

    

   > -xms 初始堆内存，-xmx 最大堆内存

   

5. <span id="5.方法区">**方法区**</span>

     ​	***线程共享***，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等。Java虚拟机规范把方法区描述为堆的一个逻辑部分，其实不是堆。而且还有很多人称方法区为永久代，其实并不等价，只是因为GC分代收集扩展至方法区。主要是针对常量池的回收和对类型的卸载。

     > -xx:Permsize 默认20.75M
     >
     > -xx:MaxPermsize 64位最大82M，32位最大64M

     

     ​	**在1.8版本中使用元空间取代了1.7及之前的永久代**。最大的区别就是元空间不在java虚拟机中，而是使用操作内存。修改原因如下：

     ​		a、1.7版本，字符串在永久代中，当字符串较多时，会造成内存不足发生溢出；由于字符串存在永久代，这就造成垃圾收集不能及时将无用字符串进行回收[^ 永久代采用Full Gc]，占用方法区内存。

     ​		b、1.7版本，方法区中还会存储虚拟机加载的类信息，和即时编译器编译后的代码，如果加载的类较多，也会造成oom。

     ​		c、永久代会为GC带来不必要的复杂度，并且回收效率不高

     

      	修改之后的好处：a、不存在元数据空间不足的情况，因为使用的就是系统内存b、FULL GC时，元空间的数据不会被扫描到

     ​	  修改之后的缺点：a、容易造成空间碎片，因为元空间的内存分配是根据类加载器分配的

     

     > -xx:MetaSpacesize  默认21M		
     >
     > -xxMaxMetaSpacesize 默认-1，没有限制
     >
     > ​		元空间的垃圾回收：元空间默认21M，超过21M，就会执行Full GC(类对应的类加载器不在存活)，经过一次Full Gc后，就会调整MetaSpacesize的大小，经过多次调整后，就会调整到最合适的大小。所以，如果前期元空间内存设置较小，会执行多次Full Gc。
     >
     > ​		且回收元空间时的类信息、字节码等只有在加载该类的类加载器被回收后，才会被回收。

      

6. <span id="6.运行时常量池">**运行时常量池**</span>

   ​	是方法区的一部分，class文件中除了有类的版本、字段、方法、接口等信息外，还有常量池。用于存放编译期间生成的各种字面量和符号引用。常量池内容在class文件被加载后就会进入运行时常量池中。

   

7. <span id="7.直接内存">**直接内存**</span>

   ​	并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。

   

---

### <span id="2">二、内存分配、对象布局 </span>

1. <span id="1.内存分配">**对象创建-内存分配**</span>

   创建对象时，内存的分配有两种方式，一指针碰撞，二空闲列表。

   **指针碰撞**，内存空间绝对规整，已使用的空间和未使用的空间区分开来，临界点就是指针。分配空间时，只需要移动相应大小内存的指针即可。缺点就是如果使用空间和未使用空间相互交错，就没有办法进行简单的指针碰撞。

    **空闲列表**，不需要内存绝地规整(已使用内存和空闲内存相互交错)，需要一块额外的空间，记录哪些空间是空闲的。在创建对象分配内存空间时，只需要查找列表即可，选出一块大小适合的空间分配之。

   

   ​    空间分配算法大致明确了，但是在并发情况下呢？就如指针碰撞，A线程分配了空间后还未来的及修改指针，B线程就已经获得指针位置了。这样就会出现问题。

   解决方案：

   ​    一、对分配内存空间的操作进行同步处理，也就是cas操作，这样效率很低，分配一个对象就需要cas操作。

   ​    二、每个线程在java堆中预先分配一小块内存，这块内存称为本地线程分配缓冲区TLAB。哪个线程需要分配内存，就在哪个TLAB上分配。只有在TLAB用完并分配新的TLAB时，才需要锁定。

   

2. <span id="2.对象布局">**对象布局**</span>

   对象=对齐填充+对象头+实例数据

   对象头=markword+klass=对象自身运行时数据+类型指针

   > 对象头长度，32位机器，32bit；64位机器，64bit
>
   > 对象头的markword存储有hash码、GC分代年龄、锁状态、等信息

   

   对象访问定位：

   **句柄访问**

   Java堆中分配一快内存作为句柄池，分别指向对象实例数据(堆)和类型(方法区)。java虚拟机栈的引用，指向句柄池，又通过句柄，获得对象实例数据和类型。

   优点：稳定，只需要改变实例数据的指针，引用类型指针不需要修改

   **直接访问**

   java虚拟机栈的引用，直接指向对象实例(堆)，只需要一次定位，速度快。

---

---



## 三、垃圾收集

1. 判断对象是否存活

   判断对象是否存活，有两种方式，一引用计数器，二可达性分析算法

   ***引用计数器***：给每个对象添加一个引用计数器，有其他地方引用，计数器+1，引用失效，计数器-1

   缺点：对象之间的循环引用，

   ***可达性分析算法***：GC Roots对象作为起点，向下搜索，搜索走过的路径为引用链，当一个对象与GC Roots	没有任务引用时，此对象不可用

   >  GC Roots对象：
   > 	栈：java虚拟机栈本地变量表中引用的对象、本地方法栈中JNI引用的对象
   >
   > ​	方法区：类静态属性引用的对象、常量引用的对象

   

2. 引用

   引用分为四种，强软弱虚。

   ***强引用***：java中普遍存在，只要强引用还在，垃圾收集器就永远不会回收掉被引用的对象

   Object A = new Object();

    

   ***软引用***：描述一些有用但是非必须的对象，将要发生内存溢出时，就会把这些对象进行回收，如果回收后，内存仍然不足，才会抛出内存溢出溢出

   SoftReference m= new SoftReference<>(new Byte[1024*1024*10]);

   m->SoftReference->(软引用)byte[]

   非常适合缓存，比如图片资源，使用软引用，如果内存不足，就会在内存不足时把资源清除

    

   ***弱引用***：描述一些有用但是非必须的对象，只能够生存到下一次垃圾收集之前

   WeakReference weakReference = new WeakReference(new Object());

    

   ***虚引用***：无法获得对象，就是这个对象被垃圾回收时收到一个系统通知

   PhantomReference phantomReference=new PhantomReference(new Object(), new ReferenceQueue());

   使用场景：释放资源，管理直接内存

    

   ***引用队列***：引用队列可以与软弱虚引用配合使用，当对象被回收时之前，就会把这个引用放到关联的引用队列中，来判断对象是否将要被回收，就可以在回收之前做一些必要措施。

   > finalize()方法，也可以在对象回收时做一些逻辑。但是更推荐使用引用对象去做这样的事。finalize()如果逻辑复杂、发生死锁、造成异常都会影响垃圾回收。	

   

3. 对象生存还是死亡

   一个对象由生到死，需要经过两次标记。

   当一个对象进行可达性分析算法后，发现与GC Roots没有任何引用链，就会被第一次标记，并进行一次筛选，筛选的条件就是是否有必要执行finalize()方法，如果有必要执行finalize()方法，就会将对象放入到F-Queue队列中。会自动创建一个低优先级finalize线程去执行finalize()方法(会触发，但是并不等待其运行结束，因为，如果finalize()方法执行缓慢或者死锁，就会导致队列中所有对象永久等待，影响整个内存回收系统)，之后会将F-Queue队列中的对象进行第二次标记，如果有对象在finalize()方法中与引用链相连，则将对象移除回收。

   > finalize()方法只会被执行一次。	

   

4. 方法区的回收

   方法区的回收，主要是废弃的常量和无用的类。

   ***废弃的常量***：和java堆中的对象一样，只有没有被引用，就会被回收

   ***无用的类***：

   ​	a、该类所有的实例被回收

   ​	b、该类的类加载器被回收

   ​	c、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。	

   

5. 垃圾收集算法

   垃圾收集算法：有标记-清除、复制算法、标记-整理、分代收集。

   ***标记-清除算法***：标记所有垃圾对象，标记完成后，统一收回

   缺点：标记和清除两个阶段所需时间都较长效率较低，产生空间碎片	

   

   ***复制算法***：将内存空间平分成两份，每次只使用一块A，当A使用完了，在将A中存活的对象复制到B中。

   优点：实现简单，运行高效。

   缺点：使用的空间直接变为一半，所以一般使用8:1:1。如果对象存活率较高是进行复制操作，效率极低。

   

   ***标记-整理***：标记对象，让所有存活的对象向一端移动，垃圾对象进行回收。

    

   ***分代收集***：将java堆分为新生代和老年代，根据不同的年代，选择不同的垃圾收集算法。

   新生代：新生代，对象存活时间较短，使用复制算法

   老年代：标记清除或者标记整理	

   

6. 枚举根节点、安全点、安全区域

   实现可达性分析算法必须考虑两点:

   ​	(1)GC Root引用链搜索，如果一个一个去搜索，时间成本太高

   ​	(2)GC Root分析时，如果还有引用在变化，无法保证准确性。

   第一个问题解决办法，使用一组oopmap数据结构，在类加载完成时，就把对象内什么偏移量是什么类型计算出来了。GC扫描时就可以直接获得了

   第二个问题解决办法，stop the word。但是这时候，什么时候进行stop the word？指令序列复用，如方法调用、循环，所以具有这些功能的指令才会产生安全点。也就是在这些地方才会创建oopmap结构。	

   >  安全点：是否有重复序列，如异常跳转、循环跳转	

   

   线程怎样到达安全点？两种方式，抢先试中断和主动式中断。

   ​	***抢先式***：先让所以线程中断，判断是不是到达安全点，没有，在恢复运行

   ​	***主动式***：设置一个标志位，所有线程去轮训，发现标志位为真，就中断。安全点和标志位重合	

   

7. 垃圾收集器

   ![1606829823648](C:\Users\Aaron\AppData\Roaming\Typora\typora-user-images\1606829823648.png)

其中垃圾收集器，Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1；

新生代：Serial、ParNew、Parallel Scavenge，全部采用复制算法

老年代：Serial Old、Parallel Old、CMS

整堆：G1



1.1 Serial

单线程、垃圾回收时stop the word，必须暂停其他所有线程(本来就是单线程，垃圾回收线程启动，其他线程肯定中断啊)

搭配：CMS(最优)、Serial Old

场景：单个cpu环境，收集效率最高(不需要上下文切换)

 

1.2 ParNew

Serial的多线程版本，除了多线程，其他和Serial一样。多线程收集唯一一个与cms搭配

垃圾回收时stop the word，暂停用户所有线程，只是在收集是，是多线程。

搭配：CMS、Serial Old

场景：1.可以允许单个cpu环境下，效率没有Serial高

 

1.3 Parallel Scavenge

和ParNew一样也是多线程，关注吞吐量，吞吐量=代码运行时间/代码运行时间+垃圾收集时间

搭配：Serial Old、Parallel Old

场景：主要适用于后台运算不需要太多交互

 

 

1.4 Serial Old

Serial 老年代版本，标记-整理算法，单线程收集

场景：client

 

 

1.5 Parallel Old

Parallel Old是Parallel Scavenge老年代版本，标记-整理算法，多线程收集，jdk1.6

场景：吞吐量

 

1.6 CMS

标记-清除算法，并发收集、低停顿，以获取最低停顿时间为目标，jdk1.5

第一次实现了垃圾收集线程和用户线程（基本上）同时运行

场景：用户交互多、注重相应速度、web服务

 

原理：四个步骤，初始标记(stw)、并发标记、重新标记(stw)、并发清除

 

初始标记(stw)

仅标记一下GC Roots能直接关联到的对象；

并发标记

进行GC Roots Tracing的过程；刚才产生的集合中标记出存活对象

重新标记(stw)

为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录；

   需要"Stop The World"，且停顿时间比初始标记稍长，但远比并发标记短；

   采用多线程并行执行来提升效率；

并发清除

 回收所有的垃圾对象；

 

并发标记耗时最长，其次重新标记，最后初始标记

 

缺点：

\1. 资源敏感，因为并发标记过程中，虽然不会导致用户线程停顿，但是占用一部分线程，会导致应用程序变慢，总吞吐量降低

\2. 浮动垃圾，并发标记过程中，也为会有用户线程也在运行，就会产生垃圾，这部分垃圾只能在下次GC时，才会被回收

\3. 标记清除，易产生碎片(使用空闲列表，内存消耗大)

 

 

1.7 G1

特点:

并行和并发

分代收集

空间整合

可预测的停顿

 

 

========Region、humongous==========

原来的堆分为新生代、老年代、新生代又可以分为eden和survivor区。

在G1收集器中将堆内存化整为零，分为大小相等的若干个Region区。G1收集器将堆内存划分为2048个Region区，每个Region区的大小根据实际情况而定，一般是1MB~32MB，2的n次幂，1 2 4 8 16 32。

region有四种类型，eden、survivor、old、humongous。一个region只能是其中一中类型。使用过程中类型是不可变的，被回收后，就可能变为其他类型。

 

在G1中新增了一个humongous。

原因：如果一个对象超过一个region的50%，就会把他直接放到old区。但是如果这个大对象存活期较短，会给垃圾回收器造成负面影响，所以新增一个humongous区，大对象直接分配到humongous区。

如果对象大于一个region，就会寻找连续的humongous区存储对象。为了寻找连续的region，有可能就会发生full gc，很多时候，会把humongous区看做老年代

 

一个region内部使用指针碰撞，一个region内还可以分配tlab。

 

========垃圾回收========

G1垃圾回收器主要三个环节，

\1. 新生代GC 	2.老年代并发标记		3.混合回收	4.可能会产生FULL GC

 

1.新生代GC，主要是针对eden区域，它在Eden空间耗尽时会被触发，Survivor不会触发。这个过程是用户线程暂停执行，多个垃圾收集线程工作

在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。

Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC停止工作，应用线程继续执行。

 

eden-》Survivor Survivor空间充足

eden-》old Survivor空间不足，部分数据直接晋升到老年代

Survivor-》Survivor

 

如果一个对象在一个eden区被引用了，在另一个eden区也被引用了。有可能old区也会引用。如果回收新生代，难道还需要把老年代的对象进行扫描吗？

这样就得不偿失了。对象扫描耗费时间，引入了Remembered Set。

使用Remembered Set避免全局扫描。

 

每个region都有一个Remembered Set，会记录其他region引用当前region中的对象。GC时，我只需要根据Remembered Set，获取引用的region。

在枚举根节点添加Remembered Set

 

将多个region中的存活对象经过复制算法放大一个空白的region中。

 

新生代需要扫描根节点、维护Remembered Set、最后复制

 

2.老年代并发标记，堆内存使用超过45%，开始此过程

 

初始标记stw，直接可达的对象、并发标记(如果这个区域对象都是垃圾，立即被回收，并计算每个区域存活对象比例)、最终标记(stw)、独占清理(stw，计算每个区域GC的回收比例，并进行排序，为混合做铺垫)、清除垃圾(清理空闲区域)

 

 

3.混合回收，老年代回收，移动到新的空闲region中，不需要回收所有的，只是扫描一小部分

老年代，会将垃圾对象占比，占比越高越优先回收 65%

可预测：混合回收，我们可以控制，因为是部分回收，每次根据允许收集时间，优先回收价值最大的区域

 

标记-压缩







[^oom]:OutOfMemoryError
[^sof]:StackOverFlowError