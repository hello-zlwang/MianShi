# 目录 #

一、jvm内存

[一、内存](#id1)

1. 程序计数器
2. java虚拟机栈
3. 本地方法栈
4. 堆
5. 方法区
6. 运行时常量池
7. 直接内存



# <span id ="id1">内存</span> #

xxx

xxx

xxx

xxx

### 一、jvm内存

---

1. **程序计数器**

   ​	***线程私有***，内存区域极小(大小几乎可以忽略不计)，可以看做是当前线程执行代码的行号指示器。用于存储指向下一条指令的地址。

   这个区域是唯一一个在java虚拟机栈中没有规定oom[^ OutOfMemory]的区域

   

   

2. **java虚拟机栈**

   ​	线程私有，生命周期与线程相同，是线程运行所需的内存空间。每个栈都由多个栈帧组成，但是每个线程只能有一个活动栈帧。

   ​	每个方法在执行的同时，就会创建一个栈帧。栈帧，用来存储局部变量表、操作数栈、动态链接、方法出口等信息。

   ​	一个方法的调用到执行完成，对应着一个栈帧的入栈和出栈。

   ​	局部变量表存储编译时期已知的各种基本类型，和对象引用。局部变量表所需的内存空间在编译器间就完成了分配。64位长度的long和double占用2个solt，其他都是1个solt。

   ​	会抛出stackoverflowerror和Outofmemoryerror。

   ​		Stackoverflowerror：超过jvm规定的最大深度

   ​		Outofmemoryerror：内存溢出

    

   内存大小设置参数：-xss size(64位下默认1M)

   

   不会发生GC，因为一个方法执行完成，对应的栈帧就会出栈，又因为线程私有，不需要进行垃圾回收，

   

3. **本地方法栈**

   线程私有，和java虚拟机作用类似，只是本地方法栈服务的是native方法

   

4. **堆**

   线程共享，是java虚拟机中管理的最大的一块内存空间。唯一目的就是存放对象实例。

   垃圾收集主要区域

    

   -xms 初始堆内存

   -xmx 最大堆内存

5. **方法区**

     线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等。

     Java虚拟机规范把方法区描述为堆的一个逻辑部分，其实不是堆。

     而且还有很多人称方法区为永久代，其实并不等价，只是因为GC分代收集扩展至方法区。

     主要是针对常量池的回收和对类型的卸载。

     1.7版本将stringtable从永久代移除了，移动到堆中。

     在1.8版本中使用元空间取代了1.7及之前的永久代。最大的区别就是元空间不在虚拟机中，而是使用操作内存

     修改原因：

     字符串在永久代中，所以垃圾收集不能及时将垃圾进行回收，导致内存不够或发生内存泄漏，oom

     方法区中还会存储虚拟机加载的类信息，和即时编译器编译后的代码，如果加载类信息较多，也会造成oom

     永久代会为GC带来不必要的复杂度，并且回收效率不高

      

     修改之后的好处：

     不存在元数据空间不足的情况，因为使用的就是系统内存

     FULL GC时，元空间的数据不会被扫描到

      

     Java虚拟机栈和本地方法栈是不需要GC的，因为出栈和入栈，就可以了。

     -xx:Permsize 默认20.75M

     -xx:MaxPermsize 64位最大82M，32位最大64M

      

     -xx:MetaSpacesize 默认21M，超过21M，就会执行Full GC(类对应的类加载器不在存活)，经过一次后Full GC后，就会调整MetaSpacesize的大小，如果前期设置较小，会经过多次Full GC-调整操作

     -xxMaxMetaSpacesize 默认-1，没有限制

      

     在MetaSpace中的类信息、字节码等只有在加载该类的类加载器被回收后，且达到MetaSpacesize默认值后，才会发生垃圾回收。

     如果ClassLoader对象一直存活，那么它所加载的类的元数据信息将不会被卸载。

      

     容器造成碎片化，因为metaspace中会根据类加载器，分配空间。如果回收后，就会造成碎片。

      

     

6. **运行时常量池**

   是方法区的一部分，class文件中除了有类的版本、字段、方法、接口等信息外，还有常量池。用于存放编译期间生成的各种字面量和符号引用。常量池内容在class文件被加载后就会进入运行时常量池中。

   

7. **直接内存**

   不是jvm的内存区域

---

---



### 二、内存分配、对象布局 ###

1. **对象创建-内存分配**

   创建对象时，内存的分配有两种方式，一指针碰撞，二空闲列表

   指针碰撞：

   内存空间绝对规整，已使用的空间和未使用的空间区分开来，临界点就是指针。分配空间时，只需要移动指针即可。

   缺点：如果使用空间和未使用空间相互交错，就无法使用

    

   空闲列表：

   维护一个列表，记录那些空间是空闲的，在分配的时候，只需要查找列表即可。

    

   所以根据这两种方法的特点，适用场景不同。

   Serial、parnew采用指针碰撞

   CMS采用空闲列表

    

   空间分配算法大致明确了，但是在并发情况下呢？就如指针碰撞，A线程分配了空间后还未来的及修改指针，B线程就已经获得指针位置了。这样就会出现问题。

   解决方案：

   一、cas操作，这样效率很低啊，分配一个对象就cas操作，

   二、每个线程在java堆中预先分配一小块内存，本地线程分配缓冲区TLAB

   

2. **对象布局**

   对象=对齐填充+对象头+实例数据

   对象头=markword+klass=对象自身运行时数据+类型指针

    

   对象头长度，32位机器，32bit；64位机器，64bit

   对象头的markword存储有hash码、GC分代年龄、锁状态、等信息

    

   对象访问定位：

   句柄访问

   Java堆中分配一快内存作为句柄池，分别指向对象实例数据(堆)和类型(方法区)

   优点：稳定，只需要改变实例数据的指针，引用类型指针不需要修改

   直接访问

   速度快，只需要一次定位

---

---



## 三、垃圾收集

1. 判断对象是否存活



[第一](D:\文档\NB\markdown语法.md)

```
[第一章节笔记](notes/note1.md)
```